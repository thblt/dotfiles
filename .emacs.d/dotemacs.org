#+TITLE: Emacs configuration
#+STARTUP: content

This is my Emacs configuration.

* Contents :TOC:noexport:
 - [[#fundamentals][Fundamentals]]
   - [[#personal-information][Personal information]]
   - [[#package-sources-and-locations][Package sources and locations]]
   - [[#general-defaults][General defaults]]
   - [[#user-interface][User interface]]
   - [[#macos][MacOS]]
 - [[#editing-text][Editing text]]
   - [[#spell-checking][Spell checking]]
   - [[#modal-editing][“Modal” editing]]
   - [[#moving-around][Moving around]]
   - [[#replace][Replace]]
   - [[#minor-modes][Minor modes]]
   - [[#customization][Customization]]
 - [[#writing-prose][Writing prose]]
   - [[#the-text-mode-hydra][The text-mode hydra]]
   - [[#common-settings-and-minor-modes][Common settings and minor modes]]
   - [[#major-modes][Major modes]]
   - [[#org-mode][Org-mode]]
 - [[#writing-code][Writing code]]
   - [[#settings][Settings]]
   - [[#minor-modes-1][Minor modes]]
   - [[#project-management-with-projectile][Project management with Projectile]]
   - [[#build-systems][Build systems]]
   - [[#programming-languages][Programming languages]]
   - [[#misc-syntaxes][Misc syntaxes]]
 - [[#tools][Tools]]
   - [[#calendars][Calendars]]
   - [[#dired][Dired]]
   - [[#ebib][Ebib]]
   - [[#magit-and-git][Magit and Git]]
   - [[#elfeed-feed-reader][Elfeed feed reader]]
   - [[#mu4e][Mu4e]]
   - [[#pdf-tools][PDF Tools]]
   - [[#regular-expression-builder][Regular expression builder]]
 - [[#conclusion][Conclusion]]

* Fundamentals

Let's say hello:

#+BEGIN_SRC emacs-lisp
  (message "
  ███████╗███╗   ███╗ █████╗  ██████╗███████╗██╗
  ██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝██║
  █████╗  ██╔████╔██║███████║██║     ███████╗██║
  ██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║╚═╝
  ███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║██╗
  ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝╚═╝
  ")
#+END_SRC

** Personal information

#+begin_src emacs-lisp
  (setq user-full-name    "Thibault Polge"
        user-mail-address "thibault@thb.lt")
#+end_src

** Package sources and locations
*** Use-package

#+BEGIN_SRC emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))

  (eval-and-compile
    (package-install 'use-package))

  (setq use-package-always-ensure t
        use-package-verbose t)

  (require 'use-package)
#+END_SRC

*** Packages from git

Some packages are not in (M)ELPA, we can grab them from git using [[https://github.com/dimitri/el-get][el-get]]:

#+begin_src emacs-lisp :tangle no
  (use-package el-get)
#+end_src

*** Development packages

The package I work are on my Code folder, and we need to load them from here:

**** Eziam

#+begin_src emacs-lisp
  (add-to-list 'load-path "/home/thblt/Documents/Code/eziam-theme-emacs")
  (add-to-list 'custom-theme-load-path "/home/thblt/Documents/Code/eziam-theme-emacs")
#+end_src

** General defaults

*** System settings

For some reason, the default value of =max-specpdl-size= prevents [[Mu4e][Mu4e]] from correctly rendering some HTML e-mails.  We increase it from 1300 to 5000.

#+BEGIN_SRC emacs-lisp
  (setq max-specpdl-size 5000)
#+END_SRC

*** Default major mode

Change the default major mode to =text-mode= instead of =fundamental-mode=.  Fundamental has no hooks.

#+begin_src emacs-lisp
  (setq-default major-mode 'text-mode)
#+end_src

*** Backups and keeping filesystem clean

Let's keep everything clean.  Backup files go to =/tmp= with autosaves.  Customize saves its mess in a separate file, to keep init.el clean.

#+begin_src emacs-lisp
  (let ((backup-dir (concat user-emacs-directory "backups/")))
    (setq backup-directory-alist `((".*" . ,backup-dir))
          auto-save-file-name-transforms `((".*" ,backup-dir t))))
#+end_src

We want numbered backups, because catastrophes happen.  The numbers may be a bit crazy, but better safe than sorry.

#+BEGIN_SRC emacs-lisp
  (setq version-control t
        kept-new-versions 500
        kept-old-versions 500)
#+END_SRC

Let's disable Customize by pointing it to =/dev/null=:

#+BEGIN_SRC emacs-lisp
  ;; Let Customize put its mess elsewhere
  (setq custom-file "/dev/null")
  (load custom-file t)
#+END_SRC

*** Browser

Use system's default browser. Using =setsid xdg-open= prevents Emacs from killing xdg-open before it actually opened anything. See [[https://askubuntu.com/questions/646631/emacs-doesnot-work-with-xdg-open][here]].

#+begin_src emacs-lisp
  (setq-default
   browse-url-browser-function 'browse-url-generic
   browse-url-generic-program "setsid"
   browse-url-generic-args '("xdg-open"))
#+end_src

*** Don't lose system clipboard

#+begin_src emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+end_src

** User interface
*** Keybindings

Rebind =C-x k= to kill the /current/ buffer.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

Rebind =C-x C-b= to =ibuffer= instead of =list-buffers=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer-other-window)
#+END_SRC

*** UI defaults

#+begin_src emacs-lisp
  (setq-default
   cursor-type 'bar
   enable-recursive-minibuffers t
   inhibit-startup-screen t
   use-dialog-box nil
   vc-follow-symlinks t

   disabled-command-function nil)
#+end_src

Never use the "safe" ~yes-or-no~ function:

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Don't show the menu bar, unless this is MacOS.  Never show toolbar or scrollbars.

#+begin_src emacs-lisp
  (unless (string= 'system-type 'darwin) (menu-bar-mode -1))
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

I don't use the right fringe

#+begin_src emacs-lisp
  (set-fringe-mode '(1 . 0))
#+end_src

Mouse wheel scrolling makes big jumps by default, let's make it smoother.

#+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
        mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
        mouse-wheel-follow-mouse 't ;; scroll window under mouse

        scroll-step 1 ;; keyboard scroll one line at a time
        )
#+end_src

*** Customization helper

A little function to identify the face at point.  Nice to have when writing themes.

#+begin_src emacs-lisp
  (defun what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+end_src

*** Fonts and themes

Configure the default font:

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono"))
  (set-face-attribute 'default nil
  ;;                  :font "DejaVu Sans Mono" ;; This breaks when Emacs is started as a daemon
                      :height (if (string-prefix-p  "rudiger" system-name) 120 090)
                      )
#+end_src

And load the default theme: [[https://github.com/thblt/eziam-theme-emacs][Eziam]].

#+begin_src emacs-lisp
  (load-theme 'eziam-light t)
#+end_src

By default, multiple themes can be loaded at the same time.  Nobody wants this (although it's required by =smart-mode-line=)

#+begin_src emacs-lisp
  (defadvice load-theme (before theme-dont-propagate activate)
    (mapc #'disable-theme custom-enabled-themes))
#+end_src

Create some shortcut commands to load both Eziam themes:

#+BEGIN_SRC emacs-lisp
  (defun eziam-dark () (interactive) (load-theme 'eziam-dark t))
  (defun eziam-light () (interactive) (load-theme 'eziam-light t))
#+END_SRC

*** Hydra

Hydras are everywhere.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

*** Ivy

#+begin_src emacs-lisp
  (use-package ivy
    :init (ivy-mode)
    :config (setq ivy-use-virtual-buffers t)
    :diminish (ivy-mode)
    )

  (use-package ivy-hydra
    )

  (use-package counsel
    :bind (
           ("M-i"     . counsel-imenu)
           ("M-x"     . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           )
    )

  (use-package swiper
    :bind (("C-S-s" . swiper))
    )
#+end_src

*** Popwin

Popwin “makes you free from the hell of annoying buffers”:

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :commands popwin-mode
    :init (popwin-mode)
    )
#+END_SRC

*** SR-Speedbar

#+BEGIN_SRC emacs-lisp
  (use-package sr-speedbar
    :init (setq sr-speedbar-right-side nil)
    :bind ("<f7>" . sr-speedbar-toggle))
#+END_SRC

*** Return focus to minibuffer

From Emacs Wiki

#+begin_src emacs-lisp
  (defun switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (select-window (active-minibuffer-window))
      (error "Minibuffer is not active")))

  (global-set-key (kbd "C-c o") 'switch-to-minibuffer) ;; Bind to `C-c o'
#+end_src

** MacOS

Some of this may be outdated, I haven't used Emacs on MacOS for a long time.

#+begin_src emacs-lisp
  (when (string= system-type 'darwin)
    ;; Don't use alt, cmd is meta
    (setq mac-option-modifier 'nil
          mac-command-modifier 'meta)

    ; Fix weird Apple keymap.on full-size kbs.
    (global-set-key (kbd "<help>") 'overwrite-mode)

    ; Fix load-path for mu4e (not sure this is still needed)
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")

    ; Load path from a shell
    (use-package exec-path-from-shell
      :init (exec-path-from-shell-initialize)))
#+end_src

* Editing text

** Spell checking

Use =aspell= instead of =ispell=:

#+begin_src emacs-lisp
  (setq ispell-program-name "aspell")
#+end_src

Don't ask before saving custom dict:

#+begin_src emacs-lisp
  (setq ispell-silently-savep t)
#+end_src

On the fly spellchecking with Flyspell:

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure nil
    :init
    (add-hook 'text-mode-hook (lambda () (flyspell-mode t)))

    :diminish flyspell-mode "Fly")
#+end_src

Correct words using Ivy instead of default method:

#+begin_src emacs-lisp
  (use-package flyspell-correct-ivy
    :after flyspell-correct  ;; M-o doesnt work without this
    :bind (("M-$" . flyspell-auto-correct-previous-word)
           :map flyspell-mode-map
           (("C-;" . flyspell-correct-previous-word-generic))))
#+end_src

Auto-dictionary mode.  Disabled for now, as it seems to slow everything down + doesn't work with org-mode.

#+begin_src emacs-lisp
  (use-package auto-dictionary
    :init (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode)))
    )
#+end_src

** TODO “Modal” editing

Selected is a package which allows to create specific bindings when region is active:

#+begin_src emacs-lisp
    (use-package selected
      :init (progn
              (setq selected-org-mode-map (make-sparse-keymap))
              (selected-global-mode))
      :diminish selected-minor-mode)
#+end_src

*** Unfill

#+BEGIN_SRC emacs-lisp
  (define-key selected-keymap (kbd "M-Q") 'unfill-region)
#+END_SRC

** Moving around
*** Avy

#+begin_src emacs-lisp
  (use-package avy
    :bind (("C-:" . avy-goto-char-timer)
           ("C-M-:" . avy-goto-char-timer)
           ("C-=" . avy-goto-line)))
#+end_src

*** iy-goto-char

Emulates Vim's =f=, =F=, =t= and =T=.

#+begin_src emacs-lisp
  (use-package iy-go-to-char
    :bind (("C-c f" . iy-go-to-char)
           ("C-c F" . iy-go-to-char-backward)
           ("C-c t" . iy-go-up-to-char)
           ("C-c T" . iy-go-up-to-char-backward)
           ("C-c ;" . iy-go-to-or-up-to-continue)
           ("C-c ," . iy-go-to-or-up-to-continue-backward)))
#+end_src

** Replace

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind (
           ("C-M-%" . vr/query-replace)
           ("C-c r" . vr/replace)
           ("C-c m" . vr/mc-mark)))
#+END_SRC

** Minor modes

*** Auto-revert-mode

#+begin_src emacs-lisp
  (eval-after-load 'autorevert
    '(diminish 'auto-revert-mode "↺")
  )
#+end_src

*** Expand-region

#+begin_src emacs-lisp
  (use-package expand-region)
#+end_src

*** Move text

Move lines of text with =M-<up>= and =M-<down>=.

#+begin_src emacs-lisp
  (use-package move-text
    :init (move-text-default-bindings)
    )
#+end_src

*** Multiple cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :init
    (add-hook 'prog-mode-hook (lambda () (multiple-cursors-mode t)))
    (add-hook 'text-mode-hook (lambda () (multiple-cursors-mode t)))
    :bind (("C-S-c C-S-c" . mc/edit-lines)))
#+end_src

*** Recentf

#+begin_src emacs-lisp
  (use-package recentf
    :init (recentf-mode)
    )
#+end_src

*** TODO Smartparens

#+begin_src emacs-lisp
  (use-package smartparens-config         ; Be smart with parentheses
    :ensure smartparens
    :init (progn
            (smartparens-global-mode)
            (show-smartparens-global-mode))
    :config (progn
              (sp-pair "“" "”")
              (sp-pair "«" "»")
              )
    :diminish (smartparens-mode))
#+end_src

I'm stealing smartparens' author config: (()

#+BEGIN_SRC emacs-lisp
  (add-hook 'minibuffer-setup-hook 'turn-on-smartparens-strict-mode)

  ;;;;;;;;;;;;;;;;;;;;;;;;
  ;; keybinding management
  (define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)

  (define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-a") 'sp-backward-down-sexp)
  (define-key smartparens-mode-map (kbd "C-S-d") 'sp-beginning-of-sexp)
  (define-key smartparens-mode-map (kbd "C-S-a") 'sp-end-of-sexp)

  (define-key smartparens-mode-map (kbd "C-M-e") 'sp-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

  (define-key smartparens-mode-map (kbd "C-M-n") 'sp-next-sexp)
  (define-key smartparens-mode-map (kbd "C-M-p") 'sp-previous-sexp)

  (define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)
  (define-key smartparens-mode-map (kbd "C-M-w") 'sp-copy-sexp)

;;  (define-key smartparens-mode-map (kbd "M-<delete>") 'sp-unwrap-sexp)
;;  (define-key smartparens-mode-map (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

  (define-key smartparens-mode-map (kbd "C-<right>") 'sp-forward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "C-<left>") 'sp-forward-barf-sexp)
  (define-key smartparens-mode-map (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "C-M-<right>") 'sp-backward-barf-sexp)

  (define-key smartparens-mode-map (kbd "M-D") 'sp-splice-sexp)
  (define-key smartparens-mode-map (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
  (define-key smartparens-mode-map (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
  (define-key smartparens-mode-map (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

  (define-key smartparens-mode-map (kbd "C-]") 'sp-select-next-thing-exchange)
  (define-key smartparens-mode-map (kbd "C-<left_bracket>") 'sp-select-previous-thing)
  (define-key smartparens-mode-map (kbd "C-M-]") 'sp-select-next-thing)

  (define-key smartparens-mode-map (kbd "M-F") 'sp-forward-symbol)
  (define-key smartparens-mode-map (kbd "M-B") 'sp-backward-symbol)

  (bind-key "C-c f" (lambda () (interactive) (sp-beginning-of-sexp 2)) smartparens-mode-map)
  (bind-key "C-c b" (lambda () (interactive) (sp-beginning-of-sexp -2)) smartparens-mode-map)

#+END_SRC

TODO: Stolen this list from xah-fly-keys:

#+BEGIN_EXAMPLE emacs-lisp
  (sp-pair "(" ")")
  (sp-pair "[" "]")
  (sp-pair "{" "}")
  (sp-pair "<" ">")
  (sp-pair "（" "）")
  (sp-pair "［" "］")
  (sp-pair "｛" "｝")
  (sp-pair "⦅" "⦆")
  (sp-pair "〚" "〛")
  (sp-pair "⦃" "⦄")
  (sp-pair "“""" "”")
  (sp-pair "‘""" "’")
  (sp-pair "‹""" "›")
  (sp-pair "«""" "»")
  (sp-pair "「" "」")
  (sp-pair "〈" "〉")
  (sp-pair "《" "》")
  (sp-pair "【" "】")
  (sp-pair "〔" "〕")
  (sp-pair "⦗" "⦘")
  (sp-pair "『" "』")
  (sp-pair "〖" "〗")
  (sp-pair "〘" "〙")
  (sp-pair "｢" "｣")
  (sp-pair "⟦" "⟧")
  (sp-pair "⟨" "⟩")
  (sp-pair "⟪" "⟫")
  (sp-pair "⟮""" "⟯")
  (sp-pair "⟬""" "⟭")
  (sp-pair "⌈""" "⌉")
  (sp-pair "⌊""" "⌋")
  (sp-pair "⦇" "⦈")
  (sp-pair "⦉" "⦊")
  (sp-pair "❛""" "❜")
  (sp-pair "❝""" "❞")
  (sp-pair "❨" "❩")
  (sp-pair "❪" "❫")
  (sp-pair "❴" "❵")
  (sp-pair "❬" "❭")
  (sp-pair "❮""" "❯")
  (sp-pair "❰" "❱")
  (sp-pair "❲" "❳")
  (sp-pair "〈" "〉")
  (sp-pair "⦑" "⦒")
  (sp-pair "⧼" "⧽")
  (sp-pair "﹙" "﹚")
  (sp-pair "﹛" "﹜")
  (sp-pair "﹝" "﹞")
  (sp-pair "⁽" "⁾")
  (sp-pair "₍" "₎")
  (sp-pair "⦋" "⦌")
  (sp-pair "⦍" "⦎")
  (sp-pair "⦏" "⦐")
  (sp-pair "⁅" "⁆")
  (sp-pair "⸢""" "⸣")
  (sp-pair "⸤""" "⸥")
  (sp-pair "⟅""" "⟆")
  (sp-pair "⦓" "⦔")
  (sp-pair "⦕" "⦖")
  (sp-pair "⸦""" "⸧")
  (sp-pair "⸨""" "⸩")
  (sp-pair "｟" "｠")
  (sp-pair "⧘""" "⧙")
  (sp-pair "⧚""" "⧛")
  (sp-pair "⸜""" "⸝")
  (sp-pair "⸌""" "⸍")
  (sp-pair "⸂""" "⸃")
  (sp-pair "⸄""" "⸅")
  (sp-pair "⸉""" "⸊")
  (sp-pair "᚛""" "᚜")
  (sp-pair "༺""" "༻")
  (sp-pair "༼""" "༽")
  (sp-pair "⏜""" "⏝")
  (sp-pair "⎴" "⎵")
  (sp-pair "⏞""" "⏟")
  (sp-pair "⏠""" "⏡")
  (sp-pair "﹁" "﹂")
  (sp-pair "﹃" "﹄")
  (sp-pair "︹" "︺")
  (sp-pair "︻" "︼")
  (sp-pair "︗" "︘")
  (sp-pair "︿" "﹀")
  (sp-pair "︽" "︾")
  (sp-pair "﹇""" "﹈")
  (sp-pair "︷" "︸")
#+END_EXAMPLE

*** Undo-tree

#+begin_src emacs-lisp
  (use-package undo-tree
    :init (global-undo-tree-mode)
    :config (setq
             undo-tree-auto-save-history t
             undo-tree-visualizer-diff t
             undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "/undo-forest" (number-to-string emacs-major-version))))
             )
    :diminish (undo-tree-mode))
#+end_src

*** Yasnippet

#+begin_src emacs-lisp
  (use-package yasnippet
    :init (yas-global-mode)
    :config (add-to-list 'yas-snippet-dirs "~./emacs.d/snippets/")
    :diminish (yas-minor-mode)
    )
#+end_src

Auto-yasnippet is a cool package for creating disposable snippets on the fly.

#+begin_src emacs-lisp
  (use-package auto-yasnippet
    :bind ( ("H-w" . aya-create)
            ("H-y" . aya-open-line)))
#+end_src

** Customization
*** TODO Autosave when losing focus

This is the initial version, which works perfectly well:

#+begin_src emacs-lisp
  (add-hook 'focus-out-hook
            (lambda ()
              (save-some-buffers t)))
#+end_src

I also tried two other solutions (not tangling):

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package auto-save-buffers-enhanced
    :init (auto-save-buffers-enhanced t))
#+END_SRC

and

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package focus-autosave-mode
    :init (focus-autosave-mode t)
    )
#+END_SRC

*** Delete trailing whitespace when saving

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Diff files before marking a buffer modified

Ignore modification-time-only changes in files, i.e. ones that don't really change the contents.  This happens often with switching between different VC buffers.  Code comes from [[http://stackoverflow.com/a/29556894][this StackOverflow question]].

#+begin_src emacs-lisp
  (defun update-buffer-modtime-if-byte-identical ()
    (let* ((size      (buffer-size))
           (byte-size (position-bytes size))
           (filename  buffer-file-name))
      (when (and byte-size (<= size 1000000))
        (let* ((attributes (file-attributes filename))
               (file-size  (nth 7 attributes)))
          (when (and file-size
                     (= file-size byte-size)
                     (string= (buffer-substring-no-properties 1 (1+ size))
                              (with-temp-buffer
                                (insert-file-contents filename)
                                (buffer-string))))
            (set-visited-file-modtime (nth 5 attributes))
            t)))))

  (defun verify-visited-file-modtime--ignore-byte-identical (original &optional buffer)
    (or (funcall original buffer)
        (with-current-buffer buffer
          (update-buffer-modtime-if-byte-identical))))
  (advice-add 'verify-visited-file-modtime :around #'verify-visited-file-modtime--ignore-byte-identical)

  (defun ask-user-about-supersession-threat--ignore-byte-identical (original &rest arguments)
    (unless (update-buffer-modtime-if-byte-identical)
      (apply original arguments)))
  (advice-add 'ask-user-about-supersession-threat :around #'ask-user-about-supersession-threat--ignore-byte-identical)

#+end_src

* Writing prose

This section deals with two things:

 1. Major modes dedicated to writing prose, as opposed to code or configuration.
 2. Non-code bits in code/configuration files: comments and integrated documentation.

** TODO The text-mode hydra

TODO validate =:= and ~=~ on all keyboard mappings.

#+BEGIN_SRC emacs-lisp
  (defhydra hydra-text-mode ()
    "text-mode switches"
    ("f" flyspell-mode "Flyspell")
    ("d" ispell-change-dictionary "Language")
    ("w" writeroom-mode "Writeroom")
    ("," text-scale-decrease "Decrease font size")
    (";" text-scale-increase "Increase font size")
    (":" writeroom-decrease-width "Decrease width")
    ("=" writeroom-increase-width "Increase width"))


  (bind-key (kbd "C-x w") 'hydra-text-mode/body text-mode-map)
#+END_SRC

** Common settings and minor modes
*** Abbrev

#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :init (add-hook 'text-mode-hook (lambda () (abbrev-mode t)))
    :diminish (abbrev-mode))
#+end_src

*** Focus

#+begin_src emacs-lisp
  (use-package focus)
#+end_src

*** Unfill

#+begin_src emacs-lisp
  (use-package unfill
    :bind (
           ("M-Q" . unfill-paragraph)))
#+end_src

*** Wordwrap/visual line

#+begin_src emacs-lisp
  (eval-after-load 'simple
    '(diminish 'visual-line-mode)
    )
#+end_src

*** Writeroom

#+begin_src emacs-lisp
  (use-package writeroom-mode ; Distraction-free mode
    :init (setq writeroom-mode-line t))
#+end_src

** Major modes
*** AucTex

#+begin_src emacs-lisp
  (use-package tex-site
    :ensure auctex ;; FIXME shouldn't this be nil?
    :init (add-hook 'LaTeX-mode-hook (lambda ()
                                       (visual-line-mode t)
                                       (TeX-fold-mode t)
                                       )
                    )
    :config (progn
              (setq-default TeX-save-query nil      ; Autosave
                            TeX-parse-self t
                            TeX-engine 'xetex
                            TeX-source-correlate-mode t ;; Synctex on
                            )))

  (eval-after-load 'reftex-vars
    '(progn
       ;; (also some other reftex-related customizations)
       (setq reftex-cite-format
             '((?\C-m . "\\cite[]{%l}")
               (?f . "\\footcite[][]{%l}")
               (?t . "\\textcite[q]{%l}")
               (?p . "\\parencite[]{%l}")
               (?o . "\\citepr[]{%l}")
               (?n . "\\nocite{%l}")))))

  (use-package company-auctex)            ; Completion provider for AucTeX
#+end_src

*** Markdown

We just load the mode.

#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src

** Org-mode

#+begin_src emacs-lisp
    (use-package org
      :pin gnu ;; Don't use Org ELPA until it gets https
      :init (progn
              (setq org-catch-invisible-edits t ; Avoid editing folded contents
                    org-hide-leading-stars t
                    org-hide-emphasis-markers t
                    org-html-htmlize-output-type 'css ; Use CSS selectors
                                            ; instead of inline
                                            ; styles in
                                            ; generated HTML
                                            ; code blocks
                    org-imenu-depth 6
                    org-src-fontify-natively t  ; Syntax highlighting in src blocks.
                    )
              (add-hook 'org-mode-hook (lambda ()
					 (org-indent-mode t)
					 (visual-line-mode t)
					 (which-function-mode t))))
      :bind (:map org-mode-map
		  ("<f1>" . org-where-am-i)))

    (eval-after-load 'org-indent
      '(diminish 'org-indent-mode)
      )
#+end_src

Some cool org extensions:

 - =toc-org= provides, guess what, automatic TOC generation for org-mode.  This is better [[https://github.com/snosov1/toc-org/issues/20#issuecomment-276407541][pinned to melpa-stable]].

  #+BEGIN_SRC emacs-lisp
    (use-package toc-org
      :init (add-hook 'org-mode-hook 'toc-org-enable)
      :pin melpa
      )
  #+END_SRC

 - =org-download= allows to drag-and-drop pictures in org-mod buffers:

  #+BEGIN_SRC emacs-lisp
    (use-package org-download)
  #+END_SRC

   No further configuration required, the package enables itself.

 - =htmlize= is required for fontifying exported HTML:

  #+begin_src emacs-lisp
    (use-package htmlize)
  #+end_src

 - We use =which-function-mode= to identify our position in Org buffers:

#+BEGIN_SRC emacs-lisp
  (defun org-where-am-i ()
    "Returns a string of headers indicating where point is in the
  current tree."
    (interactive)
    (let (headers)
      (save-excursion
	(while (condition-case nil
                   (progn
                     (push (nth 4 (org-heading-components)) headers)
                     (outline-up-heading 1))
		 (error nil))))
      (message (mapconcat #'identity headers " > "))))
#+END_SRC

*** Org-ref

#+BEGIN_SRC emacs-lisp
  (use-package org-ref
    :pin melpa)
#+END_SRC

*** TODO Hydras and selected bindings

We define a few hydras for org-mode.


 1. The *emphasize selected* bindings:

    Since use-package doesn't support binding to functions with arguments,and writing a defun for each possible emphasis is a bit overkill, we use =define-key= rather than =:bind=.

    #+BEGIN_SRC emacs-lisp
      (define-key selected-org-mode-map (kbd "*") (lambda () (interactive) (org-emphasize ?*)))
      (define-key selected-org-mode-map (kbd "b") (lambda () (interactive) (org-emphasize ?*)))
      (define-key selected-org-mode-map (kbd "/") (lambda () (interactive) (org-emphasize ?/)))
      (define-key selected-org-mode-map (kbd "i") (lambda () (interactive) (org-emphasize ?/)))
      (define-key selected-org-mode-map (kbd "_") (lambda () (interactive) (org-emphasize ?_)))
      (define-key selected-org-mode-map (kbd "+") (lambda () (interactive) (org-emphasize ?+)))
      (define-key selected-org-mode-map (kbd "~") (lambda () (interactive) (org-emphasize ?~)))
      (define-key selected-org-mode-map (kbd "=") (lambda () (interactive) (org-emphasize ?=)))
    #+END_SRC

    For some reason, this doesn't work if the lambdas aren't =(interactive)=.

 2. The *emphasize hydra*, overriding =C-c C-x C-f=.  I almost don't use this.

    #+begin_src emacs-lisp
      (defhydra hydra-org-emphasize (:exit t :hint nil)
        "
      _b_old _i_talic _u_nderline _p_re _c_ode _s_trikethrough?"

        ("b" (org-emphasize ?*) )
        ("i" (org-emphasize ?/) )
        ("u" (org-emphasize ?_) )
        ("p" (org-emphasize ?=) )
        ("c" (org-emphasize ?~) )
        ("s" (org-emphasize ?+) ))

      (define-key org-mode-map (kbd "C-c C-x C-f") 'hydra-org-emphasize/body)
    #+end_src

 3. The *visibility* hydra, which toggles contents visibility. @TODO

*** TODOs, calendar, notes

#+begin_src emacs-lisp
  (setq org-agenda-files (list "~/Documents/LOG.org")
        org-default-notes-file "~/Documents/LOG.org")
#+end_src

* Writing code

** Settings

*** Basic settings

#+begin_src emacs-lisp
  (setq-default comment-empty-lines nil
	        compile-command "wmake"
	        tab-width 2
	        c-basic-offset 2
	        cperl-indent-level 2
	        indent-tabs-mode nil)
#+end_src

*** Mappings

Nothing fancy: F5 to compile, F8 to ~ffap~.

#+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'compile)
(global-set-key (kbd "<f8>") 'ffap)
#+end_src

*** Line numbering
**** Nlinum

More efficient line numbering, especially on large files with huge foldings (eg org)

#+begin_src emacs-lisp :tangle no
  (use-package nlinum
    :init (add-hook 'prog-mode-hook 'nlinum-mode))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'linum-mode)
#+end_src

**** Linum-relative

#+begin_src emacs-lisp :tangle no
    (use-package linum-relative
      :init (add-hook 'prog-mode-hook 'linum-relative-mode))
#+end_src

** Minor modes

*** Company

#+begin_src emacs-lisp
  (use-package company
    :init (add-hook 'prog-mode-hook 'company-mode)
    :bind (:map company-mode-map
                (("M-TAB" . company-complete-common)))
    :diminish company-mode
    )
#+end_src

*** Counsel-dash

#+begin_src emacs-lisp
  (use-package counsel-dash
    :bind ("<f1>" . counsel-dash-at-point)
    :config
    (setq helm-dash-docsets-path "~/.local/share/DashDocsets")
    (defun counsel-dash-at-point ()
      (interactive)
      (counsel-dash (thing-at-point 'symbol))
      )
    )

  (add-hook 'c-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("C"))
              )
            )

  (add-hook 'c++-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("Boost" "C++" "Qt"))
              )
            )

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("Emacs Lisp"))
              )
            )

  (add-hook 'haskell-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("Haskell"))
              )
            )

  (add-hook 'html-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("HTML"))
              )
            )

  (add-hook 'js-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("JavaScript"))
              )
            )

  (add-hook 'python-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("Python 2" "Python 3"))
              )
            )
#+end_src

*** Editorconfig

#+begin_src emacs-lisp
(use-package editorconfig               ; Normalized text style file format
  :init (add-hook 'prog-mode-hook (editorconfig-mode 1))
  (add-hook 'text-mode-hook (editorconfig-mode 1))
  :diminish (editorconfig-mode)
  )
#+end_src

*** Evil Nerd Commenter

A good replacement for ~comment-dwim~, but unline [[https://github.com/remyferre/comment-dwim-2][~comment-dwim2~]], it can't alternate between commenting and commenting /out/ (adding the comment delimiter at the start or the end of the line).

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :bind (("M-;"   . evilnc-comment-or-uncomment-lines)
         ("C-M-;" . evilnc-comment-or-uncomment-paragraphs)
         ("C-c l" . evilnc-quick-comment-or-uncomment-to-the-line)
         ("C-c c" . evilnc-copy-and-comment-lines)
         ("C-c p" . evilnc-comment-or-uncomment-paragraphs)))
#+end_src

*** Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :init (add-hook 'prog-mode-hook 'flycheck-mode)
    :diminish flycheck-mode
    )
#+end_src

Use popups instead of the modeline to display flycheck errors:

#+begin_src emacs-lisp
  (use-package flycheck-pos-tip
    :after flycheck
    :init (flycheck-pos-tip-mode)
    )
#+end_src

*** Highlight-indent-guides

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :init (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    :config (setq highlight-indent-guides-method 'character
                  highlight-indent-guides-character ?┃
                  highlight-indent-guides-auto-character-face-perc 25))
#+end_src

*** Rainbow delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters)
#+end_src

*** Rainbow mode + Kurecolor

Rainbow mode is similar to Atom's Pigments plugin or something.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :init (add-hook 'prog-mode-hook (rainbow-mode))
    (add-hook 'css-mode-hook 'rainbow-mode)
    (add-hook 'scss-mode-hook 'rainbow-mode)
    :diminish (rainbow-mode))
#+end_src

Kurecolor transforms color:

#+begin_src emacs-lisp
  (use-package kurecolor)
#+end_src

** TODO Project management with Projectile

Let's load Projectile, and:

 - globally ignore undo-files and similar byproducts.
 - toggle the =C-p p= and =C-p SPC= bindings (I find the latter easier to enter, and thus more adequate for "do what I mean");

TODO: Could Projectile read ignore patterns from =~/.gitignore_global=?

#+begin_src emacs-lisp
  (use-package projectile
    :init (projectile-global-mode)
    :config (setq projectile-globally-ignored-file-suffixes (append '(
                                                                      ".un~"
                                                                      ".~undo-tree~"
                                                                      )
                                                                    projectile-globally-ignored-files))
    :diminish (projectile-mode))
#+end_src

With Ivy integration:

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :init (counsel-projectile-on) (define-prefix-command 'thblt-projectile-map)
    :config (ivy-add-actions
             ;; Allow to switch projects from counsel-projectile
             'counsel-projectile
             '(
               ("p" (lambda (_) (counsel-projectile-switch-project))
                "Switch project"
                )
               ))
    :bind (
           :map projectile-mode-map
                ("C-c p p"   . counsel-projectile)
                ("C-c p SPC" . counsel-projectile-switch-project))
    )
#+end_src

** Build systems
*** CMake

#+begin_src emacs-lisp
(use-package cmake-mode)
#+end_src

** Programming languages
*** C/C++

#+begin_src emacs-lisp
  (use-package clang-format)
  (use-package company-c-headers)
  (use-package cpputils-cmake)
  (use-package irony
    :init
    (add-hook 'c-mode-common-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

    (use-package flycheck-irony
      :init
      (eval-after-load 'flycheck
        '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup)))

    (use-package company-irony
      :init
      (eval-after-load 'company
        '(add-to-list 'company-backends 'company-irony)))

    :diminish irony-mode)



  (add-hook 'c-mode-common-hook
            (lambda ()
              (local-set-key (kbd "C-c o") 'ff-find-other-file)))
#+end_src

*** Go

#+begin_src emacs-lisp
  (use-package go-mode)
#+end_src

*** Haskell

Haskell-mode provides complete basic Haskell support:

#+begin_src emacs-lisp
  (defun thblt/find-file-back-recursive (path name)
    "Looks up NAME in PATH and all its parents.
    Returns the location it was found in, or nil."
    (if (file-exists-p (expand-file-name name path))
        path
      (let ((parent-dir (expand-file-name ".." path)))
        (if (string= parent-dir "/") nil
          (thblt/find-file-back-recursive (expand-file-name ".." path) name)))))

  (use-package haskell-mode)
#+end_src

Intero mode is a “complete interactive development program for Haskell”:

#+begin_src emacs-lisp
  (use-package intero
    :init (add-hook 'haskell-mode-hook 'intero-mode-blacklist))
#+end_src

Intero doesn't provide linting.

Intero doesn't require any further company/flycheck integration.  Thus, what follows is not required anymore:

#+begin_src emacs-lisp :tangle no
  (use-package company-ghc                ; Completion provider for Haskell
    :init (add-to-list 'company-backends '(company-ghc :with company-dabbrev-code))
    )

  (use-package flycheck-haskell           ; Haskell provider for Flycheck
    :init '(add-hook 'flycheck-mode-hook #'flycheck-haskell-setup)
    )
#+end_src

Hayoo:

#+begin_src emacs-lisp
  (use-package hayoo
    :after haskell-mode
    :bind (:map haskell-mode-map
                ("<f1>" . hayoo-query)))
#+end_src

*** Lua

#+begin_src emacs-lisp
(use-package lua-mode)
#+end_src

*** Python

#+begin_src emacs-lisp :tangle no
  (use-package company-jedi
    :config (add-hook 'python-mode-hook (progn
                                          (add-to-list 'company-backends 'company-jedi))))

  (use-package flycheck-pyflakes)
#+end_src

*** Rust

#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src

*** Web development

#+begin_src emacs-lisp
  (use-package emmet-mode)
  (use-package haml-mode)
  (use-package less-css-mode)
  (use-package scss-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.css\\'" . scss-mode))
    (setq scss-compile-at-save nil))
  (use-package skewer-mode)
  (use-package web-mode
    :init (progn
            (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))))
#+end_src

** Misc syntaxes

*** YAML

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

* Tools

This section deals with tools which don't edit anything.

** Calendars

#+BEGIN_SRC emacs-lisp
  (use-package calfw
    :pin melpa
    :init (setq
           cfw:display-calendar-holidays nil
           ;; Grid characters
           cfw:fchar-vertical-line ?│
           cfw:fchar-horizontal-line ?─
           cfw:fchar-junction ?┼
           cfw:fchar-top-junction ?┬
           cfw:fchar-top-left-corner ?╭
           cfw:fchar-top-right-corner ?╮
           cfw:fchar-left-junction ?├
           cfw:fchar-right-junction ?┤))
#+END_SRC

** Dired

I don't know Dired well, so this is nothing more than an attempt.

#+BEGIN_SRC emacs-lisp
  (use-package dired+)
#+END_SRC

** Ebib

#+begin_src emacs-lisp
(use-package ebib
  :config (setq ebib-bibtex-dialect 'biblatex)
  )
#+end_src

** Magit and Git

Git is used everywhere, so let's define a global prefix for all Git-related commands:

#+begin_src emacs-lisp
  (define-prefix-command 'thblt-git-map)
  (global-set-key (kbd "C-x g") 'thblt-git-map)
#+end_src


#+begin_src emacs-lisp
  (use-package magit
    :bind ( ("C-x g s" . magit-status)
            ("C-x g r" . magit-list-repositories)))

  (use-package git-timemachine)
#+end_src

Quickly commit changes to all open files in current project.  I only made minor changes to [[https://www.reddit.com/user/bakuretsu][bakuretsu]]'s answer to my [[https://www.reddit.com/r/emacs/comments/5k34bw/git_is_there_a_way_to_quickly_commit_changes_in/][Reddit question]].

#+begin_src emacs-lisp
  (defun thblt-magit-commit-all ()
    "Stage and commit all unstaged files open in buffers."
    (interactive)
    (require 'magit)
    (save-some-buffers t)
    (let ((unstaged-files (magit-unstaged-files))
          (file-list-buffer (get-buffer-create "*Staged Files*"))
          commit-msg)
      (if (= 0 (length unstaged-files))
          (message "No unstaged files.")
        (dolist (file unstaged-files)
          (if (get-file-buffer
               (magit-expand-git-file-name file))
              (magit-stage-file file)))
        (magit-commit)
        (delete-window (get-buffer-window file-list-buffer))
        (bury-buffer file-list-buffer))))

  (global-set-key (kbd "C-x g c") 'thblt-magit-commit-all)
#+end_src

*** magit-list-repositories

=magit-list-repositories= provides a summary view of multiple repositories.

First, let's configure the view.

#+begin_src emacs-lisp
  (setq magit-repolist-columns
        '(
          ("Name"       25  magit-repolist-column-ident nil)
          ("Branch"     10  magit-repolist-column-branch)
          ;; ("Version" 25  magit-repolist-column-version nil)
          ("Upstream"   15  magit-repolist-column-upstream)
          ("L<U"        5   thblt-magit-repolist-column-unpulled-from-upstream)
          ("L>U"        5   thblt-magit-repolist-column-unpushed-to-upstream)
          ("L<P"        5   thblt-magit-repolist-column-unpulled-from-pushremote)
          ("L>P"        5   thblt-magit-repolist-column-unpushed-to-pushremote)
          ("Dirty"      6   magit-repolist-column-dirty)
          ("Path"       99  magit-repolist-column-path nil)))
#+end_src

For some reasons, =magit-repolist-column-[unpushed-to|unpulled-from]-upstream= doesn't work.  Here's my own version.

[@TODO:  This has been [[https://github.com/magit/magit/issues/2960][fixed in magit]].  Untangle when the fix made it to a released version]

#+begin_src emacs-lisp
  (defun thblt-magit-repolist-column-unpushed-to-upstream (_id)
    "Insert number of commits in the current branch but not its upstream."
    (--when-let (magit-get-upstream-branch)
      (let ((n (car (magit-rev-diff-count "HEAD" it))))
        (propertize (number-to-string n) 'face (if (> n 0) 'bold 'shadow)))))

  (defun thblt-magit-repolist-column-unpulled-from-upstream (_id)
    "Insert number of upstream commits not in the current branch."
    (--when-let (magit-get-upstream-branch)
      (let ((n (cadr (magit-rev-diff-count "HEAD" it))))
        (propertize (number-to-string n) 'face (if (> n 0) 'bold 'shadow)))))

  (defun thblt-magit-repolist-column-unpushed-to-pushremote (_id)
    "Insert number of commits in the current branch but not its upstream."
    (--when-let (magit-get-push-branch)
      (let ((n (car (magit-rev-diff-count "HEAD" it))))
        (propertize (number-to-string n) 'face (if (> n 0) 'bold 'shadow)))))

  (defun thblt-magit-repolist-column-unpulled-from-pushremote (_id)
    "Insert number of upstream commits not in the current branch."
    (--when-let (magit-get-push-branch)
      (let ((n (cadr (magit-rev-diff-count "HEAD" it))))
        (propertize (number-to-string n) 'face (if (> n 0) 'bold 'shadow)))))
#+end_src

Then configure the list of repositories:

#+begin_src emacs-lisp
  (setq magit-repository-directories
        '(
          ("~/.dotfiles" . 1)
          ("~/.dotfiles.private". 1)
          ("~/Documents/Concours/". 1)
          ("~/Documents/Philo/". 1)
          ("~/Documents/Code/eziam-theme-emacs/". 1)
          ("~/Documents/Code/Docoptc/". 1)
          ("~/Documents/Code/haskell.thb.lt/". 1)
          ("~/Documents/Thb.lt/". 1)
          ))
#+end_src

An extra feature:  update all remotes.  Probably very dirty.

#+begin_src emacs-lisp
  (require 'cl)
  (require 'magit-repos)

  (defun thblt-magit-repolist-refresh ()
    "@TODO Add documentation"
    (interactive)
    (goto-char (point-min))
    (catch 'done
      (while t
        (--if-let (tabulated-list-get-id)
            (progn
              (cd (expand-file-name it))
              (magit-fetch-all ())))


        (when (move-text--at-last-line-p)
          (throw 'done t))

        (forward-line)
        (redisplay))
      ()
      ))

  (define-key magit-repolist-mode-map (kbd "G") 'thblt-magit-repolist-refresh)
#+end_src

** Elfeed feed reader

#+begin_src emacs-lisp
  (use-package elfeed-goodies)
  (use-package elfeed-org
    :init (setq rmh-elfeed-org-files (list "~/.emacs.d/feeds.org")))

  (use-package elfeed
    :after elfeed-goodies
    :bind (("M-<f12>" . elfeed))
    :config (progn
              (elfeed-goodies/setup)
              (elfeed-org)
              ))
#+end_src

** Mu4e

Configuration for mu4e is split between a published part, below, and a private part, tangled from =~/.emacs.d/thblt-mu4e.el=.  The public part contains common mu4e settings, the private parts defines accounts and bookmarks.

First, we /may/ need to update the load-path.  Official Debian build of Emacs don't need that, but self-built versions do:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
#+END_SRC

Each of my accounts is synced (by =mbsync=) to a folder at the root of the Maildir (eg, =~/.Mail/Academic/=).  We then need a function to switch contexts based on a regular expression on the current Maildir path.   For some reason, this doesn't come included with mu4e, so here it is, and it probably comes [[https://www.reddit.com/r/emacs/comments/47t9ec/share_your_mu4econtext_configs/d0fsih6/][from here]].

#+begin_src emacs-lisp
  (defun mu4e-message-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
          ;; if rx is a list, try each one for a match
          (or (mu4e-message-maildir-matches msg (car rx))
              (mu4e-message-maildir-matches msg (cdr rx)))
        ;; not a list, check rx
        (string-match rx (mu4e-message-field msg :maildir)))))
#+end_src

Then the bulk of the config:

#+begin_src emacs-lisp
  (use-package mu4e-maildirs-extension)
  (use-package mu4e
    :ensure nil                 ; Comes with mu, not on a Emacs package repo
    :bind (("<f12>" . mu4e)
           :map mu4e-headers-mode-map
           ("(" . mu4e-headers-prev-unread)
           (")" . mu4e-headers-next-unread)
  ;;         :map mu4e-main-mode-map
  ;;         ()
           :map mu4e-view-mode-map
           ("(" . mu4e-view-headers-prev-unread)
           (")" . mu4e-view-headers-next-unread))
    :config (progn
              (require 'mu4e-contrib)
              (mu4e-maildirs-extension)

              (setq
              ;; Use ivy
               mu4e-completing-read-function 'ivy-completing-read

               ;; General settings
               message-send-mail-function 'smtpmail-send-it
               mu4e-change-filenames-when-moving t  ; Required for mbsync
               mu4e-get-mail-command "mbsync ovh"
               mu4e-headers-auto-update t
               mu4e-html2text-command 'mu4e-shr2text
               mu4e-maildir "~/.Mail/"
               mu4e-update-interval 60 ;; seconds
               mu4e-sent-messages-behavior 'sent

               ;; UI settings
               mu4e-confirm-quit nil
               mu4e-hide-index-messages t
               mu4e-split-view 'vertical
               mu4e-headers-include-related t  ; Include related messages in threads
               mu4e-view-show-images t

               ;; UI symbols
               mu4e-use-fancy-chars t
               mu4e-headers-attach-mark '("" . "")
               mu4e-headers-encrypted-mark '("" . "")
               mu4e-headers-flagged-mark '("+" . "⚑")
               mu4e-headers-list-mark '("" . "")
               mu4e-headers-new-mark '("" . "")
               mu4e-headers-read-mark '("" . "")
               mu4e-headers-replied-mark '("" . "↩")
               mu4e-headers-seen-mark '("" . "")
               mu4e-headers-unseen-mark '("" . "")
               mu4e-headers-unread-mark '("" . "✱")
               mu4e-headers-signed-mark '("" . "")
               mu4e-headers-trashed-mark '("T" . "T")

               mu4e-headers-from-or-to-prefix '("" . "→ ")

               mu4e-headers-default-prefix '(" " . " ─")
               mu4e-headers-duplicate-prefix '("D" . "D")
               mu4e-headers-empty-parent-prefix '("X" . " X")
               mu4e-headers-first-child-prefix '("|" . "╰─")
               mu4e-headers-has-child-prefix '("+" . "╰┬")

               mu4e-headers-fields '(
                                     (:flags          . 3)
                                     (:human-date     . 12)
                                     (:from-or-to     . 25)
                                     (:thread-subject . nil)
                                     )

               mu4e-user-mail-address-list '(
                                             "thblt@thb.lt"
                                             "thibault.polge@malix.univ-paris1.fr"
                                             "thibault.polge@univ-paris1.fr"
                                             "thibault@thb.lt"
                                             "tpolge@gmail.com"
                                             )
               mu4e-context-policy 'pick-first
               mu4e-compose-context-policy 'ask)

              ;; (setq)
              (add-hook 'mu4e-view-mode-hook 'visual-line-mode)))
#+end_src

Load private configuration (we need to do this now, some later steps make use of eg bookmarks):

#+BEGIN_SRC emacs-lisp
  (let ((mu4e-private-config (expand-file-name "thblt-mu4e.org" user-emacs-directory)))

    (if (file-exists-p mu4e-private-config)
        (org-babel-load-file mu4e-private-config)
      (display-warning :warning "Private mu4e configuration missing")))
#+END_SRC

Compose messages with org-mode tables and lists:

#+begin_src emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+end_src

Enable company-mode completion in compose buffer until [[https://github.com/djcb/mu/issues/1029][this issue]] gets fixed:

#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'company-mode)
#+END_SRC

Enable notifications:

#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :init (progn
            (setq mu4e-alert-interesting-mail-query (concat "flag:unread AND " (mu4e-get-bookmark-query ?i)))
;;            (mu4e-alert-set-default-style 'libnotify)
;;            (mu4e-alert-enable-notifications)
            (mu4e-alert-enable-mode-line-display)))
#+END_SRC

** PDF Tools

#+begin_src emacs-lisp
  (use-package pdf-tools
    :init (progn (pdf-tools-install)
                 (unless (assoc "PDF Tools" TeX-view-program-list-builtin)
                   (add-to-list 'TeX-view-program-list-builtin
                                '("PDF Tools" TeX-pdf-tools-sync-view)))
                 (add-to-list 'TeX-view-program-selection
                              '(output-pdf "PDF Tools"))))
#+end_src

** Regular expression builder

We use the =string= syntax, as advised on [[https://www.masteringemacs.org/article/re-builder-interactive-regexp-builder][this Mastering Emacs' article]].

#+begin_src emacs-lisp
(setq reb-re-syntax 'string)
#+end_src
* Conclusion

We should have started (or crashed) by now.  It's time to run the server!

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start)
  )
#+end_src

We now set the initial contents of the scratch buffer.  This makes it easy to notice that something went wrong (this may not be obvious in daemon mode)

#+begin_src emacs-lisp
  (setq initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n\n")
#+end_src

And share SpongeBob's enthusiasm towards the world:

#+begin_src emacs-lisp
(defun startup-echo-area-message ()
  "I'm ready!")
#+end_src
